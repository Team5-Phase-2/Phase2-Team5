import pytest
import time
from selenium.common.exceptions import TimeoutException
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait, Select
from selenium.webdriver.support import expected_conditions as EC

# --- Configuration ---
# NOTE: Update TARGET_URL to point to your contribution page
# If running locally: TARGET_CONTRIBUTE_URL = "http://localhost:8080/contribute.html"
TARGET_CONTRIBUTE_URL = "https://dkc81a64i5ewt.cloudfront.net/contribute.html"

# Define a short timeout for API interaction waits
API_TIMEOUT_SECONDS = 10 

# Define mock inputs for the test
MOCK_URL = "https://huggingface.co/deepseek-ai/DeepSeek-V3.2"
MOCK_TYPE = "model" # Must be one of 'model', 'dataset', or 'code'

# --- Test Cases ---

def test_contribute_page_elements_present(driver):
    """
    Test 1: Check that the required form elements are present and the initial state is correct.
    """
    driver.get(TARGET_CONTRIBUTE_URL)
    wait = WebDriverWait(driver, 5)

    # 1. Check title
    assert "Contribute" in driver.title
    
    # 2. Check form title/subtitle
    assert driver.find_element(By.CLASS_NAME, "contribution-title").is_displayed()
    
    # 3. Check input fields and selectors
    url_input = wait.until(EC.visibility_of_element_located((By.ID, "artifactUrl")))
    type_select = driver.find_element(By.ID, "artifactType")
    submit_button = driver.find_element(By.ID, "submitButton")
    
    assert url_input.is_displayed()
    assert type_select.is_displayed()
    assert submit_button.is_displayed()

    # 4. Check initial button text
    assert "Submit Artifact" in submit_button.text


def test_contribute_client_side_validation(driver):
    """
    Test 2: Verify the form cannot be submitted without required fields (client-side 'required' attribute).
    """
    driver.get(TARGET_CONTRIBUTE_URL)
    wait = WebDriverWait(driver, 5)
    
    url_input = wait.until(EC.visibility_of_element_located((By.ID, "artifactUrl")))
    submit_button = driver.find_element(By.ID, "submitButton")

    # 1. Attempt to click submit without filling anything
    submit_button.click()
    
    # 2. The URL input has the 'required' attribute, so the browser should prevent the submission
    # We assert that the message container is still hidden (no error message generated by JS yet)
    message_container = driver.find_element(By.ID, "messageContainer")
    assert "hidden" in message_container.get_attribute("class"), \
        "Message container appeared, suggesting client-side validation failed."
    
    # Note: Testing browser-native validation UI (e.g., tooltips) is complex. 
    # This check ensures the JS submit handler was not triggered.


def test_contribute_api_error_handling(driver):
    """
    Test 4: Verify the UI handles a known client-side API error (e.g., 400 Bad Request) correctly.
    NOTE: This test requires a specific MOCK URL that the backend recognizes as invalid (e.g., one that always triggers a 400). 
    Since we cannot mock the API here, this test is conceptual but verifies the error state.
    """
    INVALID_URL = "http://invalid-url" # A URL expected to fail validation
    EXPECTED_ERROR_TEXT = "Submission Failed"
    API_PROCESSING_TIMEOUT = 70
    long_wait = WebDriverWait(driver, API_PROCESSING_TIMEOUT)
    driver.get(TARGET_CONTRIBUTE_URL)
    wait = WebDriverWait(driver, API_TIMEOUT_SECONDS)

    url_input = wait.until(EC.visibility_of_element_located((By.ID, "artifactUrl")))
    type_select = Select(driver.find_element(By.ID, "artifactType"))
    submit_button = driver.find_element(By.ID, "submitButton")
    message_container = driver.find_element(By.ID, "messageContainer")

    # 1. Input invalid data
    url_input.send_keys(INVALID_URL)
    type_select.select_by_value(MOCK_TYPE)

    # 2. Click submit
    submit_button.click()

    # 3. Assert: Wait for the error message to appear
    try:
        long_wait.until(
            EC.text_to_be_present_in_element_attribute(
                (By.ID, "messageContainer"), 
                "class", 
                "error"
            )
        )
        # We confirm the generic error text
        assert EXPECTED_ERROR_TEXT in message_container.text
        
    except TimeoutException:
        raise AssertionError("Expected error message did not appear.")

    # 4. Assert: UI unlocks
    wait.until(
        EC.text_to_be_present_in_element((By.ID, "submitButton"), "Submit Artifact")
    )
    assert submit_button.is_enabled() == True, "Submit button did not re-enable after error."